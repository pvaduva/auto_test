import random
import re
import math

from utils import cli, exceptions
from utils import table_parser
from utils.tis_log import LOG
from consts.auth import Tenant
from consts.cgcs import BOOT_FROM_VOLUME, UUID, ServerGroupMetadata, NovaCLIOutput, FlavorSpec, GuestImages
from keywords import keystone_helper, host_helper, common
from keywords.common import Count
from testfixtures.fixture_resources import ResourceCleanup


def create_flavor(name=None, flavor_id='auto', vcpus=1, ram=1024, root_disk=None, ephemeral=None, swap=None,
                  is_public=None, rxtx_factor=None, guest_os=None, fail_ok=False, auth_info=Tenant.ADMIN, con_ssh=None,
                  storage_backing=None, check_storage_backing=True):
    """
    Create a flavor with given criteria.

    Args:
        name (str): substring of flavor name. Whole name will be <name>-<auto_count>. e,g., 'myflavor-1'. If None, name
            will be set to 'flavor'.
        flavor_id (str): auto generated by default unless specified.
        vcpus (int):
        ram (int):
        root_disk (int):
        ephemeral (int):
        swap (int|None):
        is_public (bool):
        rxtx_factor (str):
        guest_os (str|None): guest name such as 'tis-centos-guest' or None - default tis guest assumed
        fail_ok (bool): whether it's okay to fail to create a flavor. Default to False.
        auth_info (dict): This is set to Admin by default. Can be set to other tenant for negative test.
        con_ssh (SSHClient):
        storage_backing (str): storage backing in extra flavor. Auto set storage backing based on system config if None.
            Valid values: 'local_image', 'local_lvm', 'remote'
        check_storage_backing (bool): whether to check the system storage backing configuration to auto determine the
            local_storage extra spec if storage_backing param is set to None.

    Returns (tuple): (rtn_code (int), flavor_id/err_msg (str))
        (0, <flavor_id>): flavor created successfully
        (1, <stderr>): create flavor cli rejected

    """

    candidate_args = {
        '--ephemeral': ephemeral,
        '--swap': swap,
        '--rxtx-factor': rxtx_factor,
        '--is-public': is_public
    }

    table_ = table_parser.table(cli.nova('flavor-list', ssh_client=con_ssh, auth_info=auth_info))
    existing_names = table_parser.get_column(table_, 'Name')

    if name is None:
        name = 'flavor'
    flavor_name = common.get_unique_name(name_str=name, existing_names=existing_names, resource_type='flavor')

    if root_disk is None:
        if not guest_os:
            guest_os = GuestImages.DEFAULT_GUEST
        root_disk = GuestImages.IMAGE_FILES[guest_os][1]

    mandatory_args = ' '.join([flavor_name, flavor_id, str(ram), str(root_disk), str(vcpus)])

    optional_args = ''
    for key, value in candidate_args.items():
        if value is not None:
            optional_args = ' '.join([optional_args.strip(), key, str(value)])
    subcmd = ' '.join([optional_args, mandatory_args])

    LOG.info("Creating flavor {}...".format(flavor_name))
    LOG.info("nova flavor-create option: {}".format(subcmd))
    exit_code, output = cli.nova('flavor-create', subcmd, ssh_client=con_ssh, fail_ok=fail_ok, auth_info=auth_info,
                                 rtn_list=True)

    if exit_code == 1:
        return 1, output

    table_ = table_parser.table(output)
    flavor_id = table_parser.get_column(table_, 'ID')[0]
    LOG.info("Flavor {} created successfully.".format(flavor_name))

    if not storage_backing:
        if check_storage_backing:
            LOG.info("Choose storage backing used by most hosts")
            storage_backing = get_storage_backing_with_max_hosts(con_ssh=con_ssh)[0]
        else:
            storage_backing = 'local_image'

    if storage_backing != 'local_image':
        LOG.info("Setting local_storage extra spec to {}".format(storage_backing))
        set_flavor_extra_specs(flavor_id, con_ssh=con_ssh, auth_info=auth_info,
                               **{FlavorSpec.STORAGE_BACKING: storage_backing})

    return 0, flavor_id, storage_backing


def get_storage_backing_with_max_hosts(prefer='local_image', rtn_down_hosts=False, con_ssh=None):
    """
    Get storage backing that has the most hypervisors
    Args:
        prefer (str): preferred storage_backing. If unset, local_image > local_lvm > remote
        rtn_down_hosts (bool): whether to return down hosts if no up hosts available
        con_ssh (SSHClient):

    Returns (tuple): (<storage_backing>(str), <hosts>(list))
        Examples:
            Regular/Storage system: ('local_image',['compute-1', 'compute-3'])
            AIO: ('local_lvm', ['controller-0', 'controller-1'])

    """
    up_hosts = host_helper.get_up_hypervisors(con_ssh=con_ssh)
    hosts = list(up_hosts)
    has_up_hosts = True
    if not hosts:
        has_up_hosts = False
        hosts = host_helper.get_hypervisors()
        LOG.warning("No up hypervisors. Check all hypervisors")
    hosts_len = len(hosts)

    valid_backings = ['local_image', 'local_lvm', 'remote']
    valid_backings.remove(prefer)
    valid_backings.insert(0, prefer)

    hosts_by_backing = {}
    max_num = 0
    selected_backing = prefer
    checked_len = 0
    for backing in valid_backings:
        hosts_with_backing = host_helper.get_hosts_in_storage_aggregate(backing, con_ssh=con_ssh, up_only=False)
        hosts_by_backing[backing] = hosts_with_backing
        checked_len += len(hosts_with_backing)
        if len(hosts_with_backing) >= math.ceil(hosts_len / 2):
            selected_backing = backing
            break

        if len(hosts_with_backing) > max_num:
            max_num = len(hosts_with_backing)
            selected_backing = backing
            if max_num >= hosts_len - checked_len:
                break

    selected_hosts = hosts_by_backing[selected_backing]
    if has_up_hosts or not rtn_down_hosts:
        selected_hosts = list(set(selected_hosts) & set(hosts))
    LOG.info("{} storage aggregate has most hypervisors".format(selected_backing))
    return selected_backing, selected_hosts


def flavor_exists(flavor, header='ID', con_ssh=None, auth_info=None):
    """
    Whether given flavor exists on the system
    Args:
        flavor (str): id or name of a flavor
        header (str): 'Id' or 'Name'
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (bool):

    """
    table_ = table_parser.table(cli.nova('flavor-list', ssh_client=con_ssh, auth_info=auth_info))
    return flavor in table_parser.get_column(table_, header=header)


def delete_flavors(flavor_ids, fail_ok=False, con_ssh=None, auth_info=Tenant.ADMIN):
    """
    Delete given flavor(s)
    Args:
        flavor_ids (list|str): id(s) of flavor(s) to delete
        fail_ok (bool): whether to raise exception if any flavor fails to delete
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (tuple):
        (-1, 'None of the flavor(s) exists. Do nothing.')
        (0, 'Flavor is successfully deleted')
        (1, <std_out>)
        (2, "Flavor <flavor_id> still exists on system after deleted.")

    """
    if isinstance(flavor_ids, str):
        flavor_ids = [flavor_ids]
    flavors_to_del = []
    flavors_deleted = []
    for flavor in flavor_ids:
        if flavor_exists(flavor, con_ssh=con_ssh, auth_info=auth_info):
            flavors_to_del.append(flavor)
        else:
            flavors_deleted.append(flavor)

    if not flavors_to_del:
        msg = "None of the flavor(s) provided exist on system: {}. Do nothing.".format(flavor_ids)
        LOG.info(msg)
        return -1, 'None of the flavor(s) exists. Do nothing.'

    if flavors_deleted:
        LOG.warning("Some flavor(s) do no exist on system. Skip them: {}".format(flavors_deleted))

    LOG.info("Flavor(s) to delete: {}".format(flavors_to_del))
    results = {}
    fail = False
    for flavor in flavors_to_del:
        LOG.info("Deleting flavor {}...".format(flavor))
        # Always get the result for individual flavor, so deletion will be attempted to all flavors instead of failing
        # right away upon one failure
        rtn_code, output = cli.nova('flavor-delete', flavor, fail_ok=True, ssh_client=con_ssh, auth_info=auth_info)
        if rtn_code == 1:
            result = (1, output)
            fail = True
        elif flavor_exists(flavor, con_ssh=con_ssh, auth_info=auth_info):
            result = (2, "Flavor {} still exists on system after deleted.".format(flavor))
            fail = True
        else:
            result = (0, 'Flavor is successfully deleted')
        results[flavor] = result
    if fail:
        if fail_ok:
            return 1, results
        raise exceptions.FlavorError("Failed to delete flavor(s). Details: {}".format(results))

    success_msg = "Flavor(s) deleted successfully."
    LOG.info(success_msg)
    return 0, success_msg


def get_flavor_id(name=None, memory=None, disk=None, ephemeral=None, swap=None, vcpu=None, rxtx=None, is_public=None,
                  con_ssh=None, auth_info=None, strict=True):
    """
    Get a flavor id with given criteria. If no criteria given, a random flavor will be returned.

    Args:
        name (str): name of a flavor
        memory (int): memory size in MB
        disk (int): size of the disk in GB
        ephemeral (int): size of ephemeral disk in GB
        swap (int): size of swap disk in GB
        vcpu (int): number of vcpus
        rxtx (str):
        is_public (bool):
        con_ssh (SSHClient):
        auth_info (dict):
        strict (bool): whether or not to perform strict search on provided values

    Returns (str): id of a flavor

    """
    if str(swap) == '0':
        swap = ''

    req_dict = {'Name': name,
                'Memory_MB': memory,
                'Disk': disk,
                'Ephemeral': ephemeral,
                'Swap': swap,
                'VCPUs': vcpu,
                'RXTX_Factor': rxtx,
                'IS_PUBLIC': is_public,
                }

    final_dict = {}
    for key, val in req_dict.items():
        if val is not None:
            final_dict[key] = str(val)

    table_ = table_parser.table(cli.nova('flavor-list', ssh_client=con_ssh, auth_info=auth_info))

    if not final_dict:
        ids = table_parser.get_column(table_, 'ID')
    else:
        ids = table_parser.get_values(table_, 'ID', strict=strict, **final_dict)
    if not ids:
        return ''
    return random.choice(ids)


def get_basic_flavor(auth_info=None, con_ssh=None, guest_os=''):
    """
    Get a basic flavor with the default arg values and without adding extra specs.
    Args:
        auth_info (dict):
        con_ssh (SSHClient):
        guest_os

    Returns (str): id of the basic flavor

    """
    if not guest_os:
        guest_os = GuestImages.DEFAULT_GUEST
    size = GuestImages.IMAGE_FILES[guest_os][1]

    default_flavor_name = 'flavor-default-size{}'.format(size)
    flavor_id = get_flavor_id(name=default_flavor_name, con_ssh=con_ssh, auth_info=auth_info, strict=False)
    if flavor_id == '':
        flavor_id = create_flavor(name=default_flavor_name, root_disk=size, con_ssh=con_ssh)[1]
        ResourceCleanup.add('flavor', flavor_id, scope='session')

    return flavor_id


def set_flavor_extra_specs(flavor, con_ssh=None, auth_info=Tenant.ADMIN, fail_ok=False, **extra_specs):
    """
    Set given extra specs for a flavor
    Args:
        flavor (str): id of a flavor
        con_ssh (SSHClient):
        auth_info (dict):
        fail_ok (bool):
        **extra_specs: extra specs to set. e.g., **{"hw:mem_page_size": "2048"}

    Returns (tuple): (rtn_code (int), message (str))
        (0, 'Flavor extra specs set successfully.'): required extra spec(s) added successfully
        (1, <stderr>): add extra spec cli rejected
        (2, 'Required extra spec <spec_name> is not found in the extra specs list'): post action check failed
        (3, 'Extra spec value for <spec_name> is not <spec_value>'): post action check failed

    """
    if not extra_specs:
        raise ValueError("extra_specs is not provided. At least one name=value pair is required.")

    LOG.info("Setting flavor extra specs: {}".format(extra_specs))
    extra_specs_args = ''
    for key, value in extra_specs.items():
        extra_specs_args += " {}={}".format(key, value)
    exit_code, output = cli.nova('flavor-key', '{} set {}'.format(flavor, extra_specs_args.strip()),
                                 ssh_client=con_ssh, auth_info=auth_info, fail_ok=fail_ok, rtn_list=True)

    if exit_code == 1:
        return 1, output

    extra_specs = get_flavor_extra_specs(flavor, con_ssh=con_ssh, auth_info=auth_info)
    for key, value in extra_specs.items():
        if key not in extra_specs:
            code = 2
            msg = "Required extra spec {} is not found in the extra specs list".format(key)
            break
        if extra_specs[key] != value:
            code = 3
            msg = "Extra spec value for {} is not {}".format(key, value)
            break
    else:
        code = 0
        msg = "Flavor extra specs set successfully."

    if code > 0:
        if fail_ok:
            LOG.warning(msg)
        else:
            raise exceptions.FlavorError(msg)
    else:
        LOG.info(msg)

    return code, msg


def unset_flavor_extra_specs(flavor, extra_specs, check_first=True, fail_ok=False, auth_info=Tenant.ADMIN,
                             con_ssh=None):
    """
    Unset specific extra spec(s) from given flavor.

    Args:
        flavor (str): id of the flavor
        con_ssh (SSHClient):
        auth_info (dict):
        fail_ok (bool):
        extra_specs (str|list): extra spec(s) to be removed. At least one should be provided.
        check_first (bool): Whether to check if extra spec exists in flavor before attempt to unset

    Returns (tuple): (rtn_code (int), message (str))
        (-1, 'Extra spec(s) <specs> not exist in flavor. Do nothing.')
        (0, 'Flavor extra specs unset successfully.'): required extra spec(s) removed successfully
        (1, <stderr>): unset extra spec cli rejected
        (2, '<spec_name> is still in the extra specs list'): post action check failed

    """

    LOG.info("Unsetting flavor extra spec(s): {}".format(extra_specs))

    if isinstance(extra_specs, str):
        extra_specs = [extra_specs]

    if check_first:
        keys_to_del = []
        existing_specs = get_flavor_extra_specs(flavor, con_ssh=con_ssh, auth_info=auth_info)
        for key in extra_specs:
            if key in existing_specs:
                keys_to_del.append(key)
        if not keys_to_del:
            msg = "Extra spec(s) {} not exist in flavor. Do nothing.".format(extra_specs)
            LOG.info(msg)
            return -1, msg

        extra_specs = keys_to_del

    extra_specs_args = ' '.join(extra_specs)
    exit_code, output = cli.nova('flavor-key', '{} unset {}'.format(flavor, extra_specs_args),
                                 ssh_client=con_ssh, auth_info=auth_info, fail_ok=fail_ok, rtn_list=True)
    if exit_code == 1:
        return 1, output

    post_extra_specs = get_flavor_extra_specs(flavor, con_ssh=con_ssh, auth_info=auth_info)
    for key in extra_specs:
        if key in post_extra_specs:
            err_msg = "{} is still in the extra specs list after unset.".format(key)
            if fail_ok:
                LOG.warning(err_msg)
                return 2, err_msg
            raise exceptions.FlavorError(err_msg)
    else:
        success_msg = "Flavor extra specs unset successfully."
        LOG.info(success_msg)
        return 0, success_msg


def get_flavor_extra_specs(flavor, con_ssh=None, auth_info=Tenant.ADMIN):
    """
    Get extra specs of a flavor as dictionary
    Args:
        flavor (str): id of a flavor
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (dict): e.g., {"aggregate_instance_extra_specs:storage": "local_image", "hw:mem_page_size": "2048"}

    """
    table_ = table_parser.table(cli.nova('flavor-show', flavor, ssh_client=con_ssh, auth_info=auth_info))
    extra_specs = eval(table_parser.get_value_two_col_table(table_, 'extra_specs'))

    return extra_specs


def create_server_group(name=None, policy='affinity', best_effort=None, max_group_size=None, fail_ok=False,
                        auth_info=None, con_ssh=None, rtn_exist=False, **metadata):
    """
    Create a server group with given criteria

    Args:
        name (str): name of the server group
        policy (str): affinity or anti_infinity
        best_effort (bool): best effort metadata value
        max_group_size (int): max instances allowed in this server group
        fail_ok (bool):
        auth_info (dict):
        con_ssh (SSHClient):
        rtn_exist (bool): Whether to return existing server group that matches the given name
        **metadata: key, value metadata pairs except group size and best effort.

    Returns (tuple): (rtn_code (int), err_msg_or_srv_grp_id (str))
        - (0, <server_group_id>)    # server group created successfully
        - (1, <stderr>)     # create server group cli rejected

    """
    # process server group metadata
    if name is not None and rtn_exist:
        existing_grp = get_server_groups(name=name, strict=False, con_ssh=con_ssh, auth_info=auth_info)
        if existing_grp:
            LOG.debug("Returning existing server group {}".format(existing_grp[0]))
            return -1, existing_grp[0]

    args = ''
    if best_effort is not None or max_group_size is not None or metadata:
        tmp_list = []
        if best_effort is not None:
            tmp_list.append('{}={}'.format(ServerGroupMetadata.BEST_EFFORT, best_effort))
        if max_group_size is not None:
            tmp_list.append('{}={}'.format(ServerGroupMetadata.GROUP_SIZE, max_group_size))
        if metadata:
            for key, value in metadata.items():
                tmp_list.append('{}={}'.format(key, value))
        args += '--metadata ' + ','.join(tmp_list)

    # process server group name
    if name is None:
        name = 'srv_grp'
    args += " {}-{}".format(name, Count.get_sever_group_count())

    policy = policy.replace('_', '-')
    # process server group policy
    args += ' ' + policy

    LOG.info("Creating server group with args: {}...".format(args))
    exit_code, output = cli.nova('server-group-create', args, ssh_client=con_ssh, fail_ok=fail_ok, auth_info=auth_info,
                                 rtn_list=True)

    if exit_code == 1:
        return 1, output

    table_ = table_parser.table(output)
    srv_grp_id = table_parser.get_column(table_, 'Id')[0]
    LOG.info("Server group {} created successfully.".format(srv_grp_id))
    return 0, srv_grp_id


def get_server_groups(name=None, project_id=None, auth_info=Tenant.ADMIN, con_ssh=None, strict=False, regex=False,
                      all_=True, **kwargs):
    """
    Get server groups ids based on the given criteria

    Args:
        name (str): filter out server groups with given name
        project_id (str): filter out server groups for given tenant id
        auth_info (dict):
        con_ssh (SSHClient):
        strict (bool): whether to do strict search for name and value(s) in kwargs
        regex (bool): whether or not to use regex
        all_(bool): whether to append '--a' to cli
        **kwargs: extra key/value pair(s) to filter the table. e.g., Policies = 'affinity'

    Returns (list): list of server groups ids

    """
    arg = '--a' if all_ else ''

    table_ = table_parser.table(cli.nova('server-group-list', arg, ssh_client=con_ssh, auth_info=auth_info))

    if name is not None:
        table_ = table_parser.filter_table(table_, strict=strict, regex=regex, Name=name)

    if project_id is not None:
        table_ = table_parser.filter_table(table_, strict=True, **{"Project Id": project_id})

    return table_parser.get_values(table_, 'Id', strict=strict, regex=regex, **kwargs)


def get_server_groups_info(server_groups=None, header='Policies', auth_info=None, con_ssh=None):
    """
    Get a server group(s) info as a list

    Args:
        server_groups (str|list): id(s) of server group(s).
        header (str): header string for info. such as 'Member', 'Metadata', 'Policies'
        auth_info (dict):
        con_ssh (SSHClient):

    Returns (list): server group(s) info as a list

    """
    table_ = table_parser.table(cli.nova('server-group-list', '--a', ssh_client=con_ssh, auth_info=auth_info))
    if server_groups:
        table_ = table_parser.filter_table(table_, Id=server_groups)

    return table_parser.get_column(table_, header)


def set_server_group_metadata(srv_grp_id, fail_ok=False, auth_info=None, con_ssh=None, **metadata):
    """
    Set server group metadata with given key/value pair(s)
    Args:
        srv_grp_id (str): server group id
        fail_ok (bool):
        auth_info (dict):
        con_ssh (SSHClient):
        **metadata: metadata key/value pair(s) to set

    Returns (tuple):
        (0, "Server group metadata successfully set: <metadata>")
        (1, <stderr>)
        (2. "Server group metadata <key> is not set to <value>")

    """
    if not metadata:
        raise ValueError("At least one metadata key-value pair needs to be provided.")

    LOG.info("Setting metadata {} for server group {}".format(metadata, srv_grp_id))

    args = srv_grp_id
    metadata_to_check = {}
    for key, value in metadata.items():
        key = key.lower()
        value = str(value).lower()
        metadata_to_check[key] = value
        args += ' {}={}'.format(key, value)

    code, output = cli.nova('server-group-set-metadata', args, ssh_client=con_ssh, auth_info=auth_info, rtn_list=True,
                            fail_ok=fail_ok)

    if code == 1:
        return 1, output

    post_set_metadata = eval(table_parser.get_values(table_parser.table(output), 'Metadata', Id=srv_grp_id)[0])
    for key, value in metadata_to_check.items():
        if not post_set_metadata[key] == value:
            msg = "Server group metadata {} is not set to {}".format(srv_grp_id, key, value)
            if fail_ok:
                LOG.warning(msg)
                return 2, msg
            raise exceptions.NovaError(msg)

    msg = "Server group metadata successfully set: {}".format(metadata_to_check)
    LOG.info(msg)
    return 0, msg


def unset_server_group_metadata(srv_grp_id, fail_ok=False, auth_info=None, con_ssh=None, *metadata):
    """
    Unset given metadata(s) for a server group
    Args:
        srv_grp_id (str): id of a server group
        fail_ok (bool):
        auth_info (dict):
        con_ssh (SSHClient):
        *metadata: metadata key(s) to unset

    Returns (tuple):
        (0, "Server group metadata successfully unset: <metadata_keys>")
        (1, <stderr>)
        (2, "Some metadata for server group <srv_grp_id> failed to unset: <metadata_keys>)

    """
    if not metadata:
        raise ValueError("At least one metadata name needs to be provided.")

    LOG.info("Unsetting metadata {} for server group {}".format(metadata, srv_grp_id))

    args = srv_grp_id + ' '
    metadata = [item.lower() for item in metadata]
    args += ' '.join([str(item) + "=" for item in metadata])

    code, output = cli.nova('server-group-set-metadata', args, ssh_client=con_ssh, auth_info=auth_info, rtn_list=True,
                            fail_ok=fail_ok)

    if code == 1:
        return 1, output

    post_set_metadata = eval(table_parser.get_values(table_parser.table(output), 'Metadata', Id=srv_grp_id))

    undeleted_keys = list(set(metadata) - set(post_set_metadata.keys()))

    if undeleted_keys:
        msg = "Some metadata for server group {} failed to unset: {}".format(srv_grp_id, undeleted_keys)
        if fail_ok:
            LOG.warning(msg)
            return 2, msg
        raise exceptions.NovaError(msg)

    msg = "Server group metadata successfully unset: {}".format(metadata)
    LOG.info(msg)
    return 0, msg


def server_group_exists(srv_grp_id, auth_info=Tenant.ADMIN, con_ssh=None):
    """
    Return True if given server group exists else False

    Args:
        srv_grp_id (str):
        auth_info (dict):
        con_ssh (SSHClient):

    Returns (bool): True or False

    """
    table_ = table_parser.table(cli.nova('server-group-list', '--a', ssh_client=con_ssh, auth_info=auth_info))
    existing_server_groups = table_parser.get_column(table_, 'Id')

    return srv_grp_id in existing_server_groups


def delete_server_groups(srv_grp_ids=None, check_first=True, fail_ok=False, auth_info=Tenant.ADMIN, con_ssh=None):
    """
    Delete server group(s)

    Args:
        srv_grp_ids (list|str): id(s) for server group(s) to delete.
        check_first (bool): whether to check existence of given server groups before attempt to delete. Default: True.
        fail_ok (bool):
        auth_info (dict|None):
        con_ssh (SSHClient):

    Returns (tuple): (rtn_code(int), msg(str))  # rtn_code 1,2,3,4 only returns when fail_ok=True
        (-1, 'No server group(s) to delete.')     # "Empty vm list/string provided and no vm exist on system.
        (-1, 'None of the given server group(s) exists on system.')
        (0, "Server group(s) deleted successfully.")
        (1, <stderr>)   # Deletion rejected for all of the server groups. Return CLI stderr.
        (2, "Deletion rejected for some server group(s): <srv_grp_ids>")
        (3, "Deletion rejected for some server group(s) and some deleted server groups still exist on system: <srv_grp_ids>")
        (4, "Some deleted server group(s) still exist on system:: <srv_grp_ids>")
    """
    if srv_grp_ids is None:
        srv_grp_ids = get_server_groups(con_ssh=con_ssh, auth_info=auth_info)

    if isinstance(srv_grp_ids, str):
        srv_grp_ids = [srv_grp_ids]

    LOG.info("Deleting server group(s): {}".format(srv_grp_ids))

    for server_group in srv_grp_ids:
        if server_group:
            break
    else:
        LOG.warning("Empty server group list/string provided and no server group exists on system. Do Nothing")
        return -1, 'No server group(s) to delete.'

    if check_first:
        grps_to_del = []
        for server_group in srv_grp_ids:
            grp_exist = server_group_exists(server_group, con_ssh=con_ssh)
            if grp_exist:
                grps_to_del.append(server_group)
        if not grps_to_del:
            LOG.info("None of these server groups exist on system: {}. Do nothing".format(srv_grp_ids))
            return -1, 'None of the given server group(s) exists on system.'
    else:
        grps_to_del = srv_grp_ids

    grps_to_del_str = ' '.join(grps_to_del)

    code, output = cli.nova('server-group-delete', grps_to_del_str, ssh_client=con_ssh, timeout=60, fail_ok=True,
                            rtn_list=True, auth_info=auth_info)

    if code == 1:
        return 1, output

    grps_del_accepted = re.findall(NovaCLIOutput.SRV_GRP_DEL_SUCC, output)
    grps_del_rejected = list(set(grps_to_del) - set(grps_del_accepted))

    # check if server groups are actually removed from nova server-group-list
    grps_undeleted = []
    for grp in grps_del_accepted:
        if server_group_exists(grp):
            grps_undeleted.append(grp)

    if grps_del_rejected:
        if grps_undeleted:
            msg = "Deletion rejected for some server group(s) and some deleted server groups still exist on system: " \
                  "{}".format(grps_del_rejected, grps_undeleted)
            if fail_ok:
                LOG.warning(msg)
                return 3, msg
            raise exceptions.NovaError(msg)
        else:
            msg = "Deletion rejected for some server group(s): {}".format(grps_del_rejected)
            if fail_ok:
                LOG.warning(msg)
                return 2, msg
            raise exceptions.NovaError(msg)

    elif grps_undeleted:
        msg = "Some deleted server group(s) still exist on system: {}".format(grps_undeleted)
        if fail_ok:
            LOG.warning(msg)
            return 4, msg
        raise exceptions.NovaError(msg)

    else:
        msg = "Server group(s) deleted successfully."
        LOG.info(msg)
        return 0, "Server group(s) deleted successfully."


def get_all_vms(return_val='ID', con_ssh=None):
    """
    Get VMs for all tenants in the systems

    Args:
        return_val:
        con_ssh:

    Returns (list): list of all vms on the system

    """
    table_ = table_parser.table(cli.nova('list', '--all-tenants', ssh_client=con_ssh, auth_info=Tenant.ADMIN))
    return table_parser.get_column(table_, return_val)


def get_field_by_vms(vm_ids=None, field="Status", con_ssh=None, auth_info=None):
    """
    get a dictionary in the form {vm_id:field,vm_id:field...} for a specific field

    Args:
        vm_ids (list or str):a list of vm ids OR a vm id in string
        field (str): A specific field header Such as Name,Status,Power State
        con_ssh (str):
        auth_info (dict):
    Returns (dict):
        A dict with vm_ids as key and an field's value as value.
        If the list is Empty return all the Ids with their status

    """
    ids_status = {}
    # list is empty then return the whole list with their status
    if not vm_ids:
        vm_ids = get_vms(con_ssh=con_ssh)

    if isinstance(vm_ids, str):
        vm_ids = [vm_ids]

    table_ = table_parser.table(cli.nova('list', '--all-tenants', ssh_client=con_ssh, auth_info=auth_info))

    for vm in vm_ids:
        ids_status[vm] = table_parser.get_values(table_=table_, target_header=field, ID=vm)

    return ids_status


def get_vm_storage_type(vm_id, con_ssh=None):
    """
    Get storage type from the flavor extra spec for given vm
    Args:
        vm_id (str):
        con_ssh (SSHClient):

    Returns (str): storage extra spec value. Possible return values: 'local_image', 'local_lvm', or 'remote'

    """
    # TODO: Update to get it from nova show directly
    flavor_id = get_vm_flavor(vm_id=vm_id, rtn_val='id')

    table_ = table_parser.table(cli.nova('flavor-show', flavor_id, ssh_client=con_ssh, auth_info=Tenant.ADMIN))
    extra_specs = eval(table_parser.get_value_two_col_table(table_, 'extra_specs'))
    return extra_specs['aggregate_instance_extra_specs:storage']


def get_vms(vms=None, return_val='ID', con_ssh=None, auth_info=None, all_vms=True, strict=True, regex=False, **kwargs):
    """
    get a list of VM IDs or Names for given tenant in auth_info param.

    Args:
        vms (list): filter vms from this list if not None
        return_val (str): 'ID' or 'Name'
        con_ssh (SSHClient): controller SSHClient.
        auth_info (dict): such as ones in auth.py: auth.ADMIN, auth.TENANT1
        all_vms (bool): whether to return VMs for all tenants if admin auth_info is given
        strict (bool): applies to search for value(s) specified in kwargs
        regex (bool): whether to use regular expression to search for the kwargs value(s)
        **kwargs: header/value pair to filter out the vms

    Returns (list): list of VMs for tenant(s).

    """
    positional_args = ''
    if all_vms is True:
        if auth_info is None:
            auth_info = Tenant.get_primary()
        if auth_info['tenant'] == 'admin':
            positional_args = '--all-tenants'
    table_ = table_parser.table(cli.nova('list', positional_args=positional_args, ssh_client=con_ssh,
                                         auth_info=auth_info))
    if vms:
        table_ = table_parser.filter_table(table_, ID=vms)

    if kwargs:
        return table_parser.get_values(table_, return_val, strict=strict, regex=regex, **kwargs)
    else:
        return table_parser.get_column(table_, return_val)


def get_vm_nova_show_values(vm_id, fields, strict=False, con_ssh=None, auth_info=Tenant.ADMIN):
    """
    Get vm nova show values for given fields
    Args:
        vm_id (str):
        fields (list):
        strict (bool):
        con_ssh:
        auth_info:

    Returns (list): list of values

    """
    table_ = table_parser.table(cli.nova('show', vm_id, ssh_client=con_ssh, auth_info=auth_info))
    values = []
    for field in fields:
        value = table_parser.get_value_two_col_table(table_, field, strict)
        values.append(value)
    return values


def get_vm_status(vm_id, con_ssh=None, auth_info=Tenant.ADMIN):
    return get_vm_nova_show_value(vm_id, 'status', strict=True, con_ssh=con_ssh, auth_info=auth_info)


def get_vm_id_from_name(vm_name, con_ssh=None, strict=True, regex=False, fail_ok=True):
    table_ = table_parser.table(cli.nova('list', '--all-tenants', ssh_client=con_ssh, auth_info=Tenant.ADMIN))
    vm_ids = table_parser.get_values(table_, 'ID', strict=strict, regex=regex, Name=vm_name.strip())
    if not vm_ids:
        if fail_ok:
            return None
        raise exceptions.VMError("No vm with name {} found".format(vm_name))

    return vm_ids[0]


def get_vm_name_from_id(vm_id, con_ssh=None):
    table_ = table_parser.table(cli.nova('list', '--all-tenants', ssh_client=con_ssh, auth_info=Tenant.ADMIN))
    return table_parser.get_values(table_, 'Name', ID=vm_id)[0]


def get_vm_volumes(vm_id, con_ssh=None, auth_info=None):
    """
    Get volume ids attached to given vm.

    Args:
        vm_id (str):
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (tuple): list of volume ids attached to specific vm

    """
    table_ = table_parser.table(cli.nova('show', vm_id, ssh_client=con_ssh, auth_info=auth_info))
    return _get_vm_volumes(table_)


def get_vm_nova_show_value(vm_id, field, strict=False, con_ssh=None, auth_info=Tenant.ADMIN, use_openstack_cmd=False):
    """
    Get vm nova show value for given field
    Args:
        vm_id (str):
        field (str): field name in nova show table
        strict (bool): whether to perform a strict search on given field name
        con_ssh (SSHClient):
        auth_info (dict):
        use_openstack_cmd:

    Returns (str|list): value of specified field. Return list for multi-line value

    """
    if use_openstack_cmd:
        table_ = table_parser.table(cli.openstack('server show', vm_id, ssh_client=con_ssh, auth_info=auth_info))
    else:
        table_ = table_parser.table(cli.nova('show', vm_id, ssh_client=con_ssh, auth_info=auth_info))

    merge = False
    if field in ['fault']:
        merge = True
    return table_parser.get_value_two_col_table(table_, field, strict, merge_lines=merge)


def get_vm_fault_message(vm_id, con_ssh=None, auth_info=None):
    table_ = table_parser.table(cli.nova('show', vm_id, ssh_client=con_ssh, auth_info=auth_info))
    return table_parser.get_value_two_col_table(table_, 'fault', merge_lines=True)


def get_vms_info(vm_ids=None, field='Status', con_ssh=None, auth_info=Tenant.ADMIN):
    """
    Get value of specified field for given vm(s) as a dictionary.
    Args:
        vm_ids (list|str):
        field (str):
        con_ssh:
        auth_info:

    Returns (dict): e.g.,{<vm_id1>: <value of the field for vm1>, <vm_id2>: <value of the field for vm2>}

    """
    args = '--all-tenants' if auth_info['tenant'] == 'admin' else ''

    table_ = table_parser.table(cli.nova('list', args, ssh_client=con_ssh, auth_info=auth_info))
    if vm_ids:
        table_ = table_parser.filter_table(table_, ID=vm_ids)
    else:
        vm_ids = table_parser.get_column(table_, header='ID')

    info = table_parser.get_column(table_, header=field)
    return dict(zip(vm_ids, info))


def get_vm_flavor(vm_id, rtn_val='id', con_ssh=None, auth_info=Tenant.ADMIN):
    """
    Get flavor id of given vm

    Args:
        vm_id (str):
        rtn_val (str): id or name
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (str):

    """
    flavor = get_vm_nova_show_value(vm_id, field='flavor:original_name', strict=True, con_ssh=con_ssh,
                                    auth_info=auth_info)
    if 'id' in rtn_val:
        flavor = get_flavor_id(name=flavor, strict=True, con_ssh=con_ssh, auth_info=auth_info)

    return flavor


def get_vm_host(vm_id, con_ssh=None):
    """
    Get host of given vm
    Args:
        vm_id:
        con_ssh:

    Returns:

    """
    return get_vm_nova_show_value(vm_id, ':host', strict=False, con_ssh=con_ssh, auth_info=Tenant.ADMIN)


def get_vms_on_hypervisor(hostname, con_ssh=None, rtn_val='ID'):
    """

    Args:
        rtn_val: ID or Name
        hostname (str):Name of a compute node
        con_ssh:

    Returns (list): A list of VMs' ID under a hypervisor

    """
    table_ = table_parser.table(cli.nova('hypervisor-servers', hostname, ssh_client=con_ssh, auth_info=Tenant.ADMIN))
    return table_parser.get_column(table_, rtn_val)


def get_vms_by_hypervisors(con_ssh=None, rtn_val='ID'):
    """

    Args:
        con_ssh (SSHClient):
        rtn_val (str): ID or Name. Whether to return Names or IDs

    Returns (dict):return a dictionary where the host(hypervisor) is the key
    and value are a list of VMs under the host

    """
    host_vms = {}
    for host in host_helper.get_hypervisors(con_ssh=con_ssh):
        host_vms[host] = get_vms_on_hypervisor(host, con_ssh, rtn_val=rtn_val)

    return host_vms


def get_key_pair(name=None, con_ssh=None, auth_info=None):
    """

    Args:
        name (str): Name of the key pair to filter for a given user
        con_ssh (SSHClient):
        auth_info (dict): Tenant to be used to execute the cli if none Primary tenant will be used

    Returns (dict):return the name of the keypairs

    """
    table_ = table_parser.table(cli.nova('keypair-list', ssh_client=con_ssh, auth_info=auth_info))
    if name is not None:
        return table_parser.get_values(table_, 'Name', Name=name)
    else:
        return table_parser.get_column(table_, 'Name')


def vm_exists(vm_id, con_ssh=None, auth_info=Tenant.ADMIN):
    """
    Return True if VM with given id exists. Else False.

    Args:
        vm_id (str):
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (bool):
    """
    exit_code, output = cli.nova('show', vm_id, fail_ok=True, ssh_client=con_ssh, auth_info=auth_info, rtn_list=True)
    return exit_code == 0


def get_vm_boot_info(vm_id, auth_info=None, con_ssh=None):
    """
    Get vm boot source and id.

    Args:
        vm_id (str):
        auth_info (dict):
        con_ssh (SSHClient):

    Returns (dict): VM boot info dict. Format: {'type': <boot_source>, 'id': <source_id>}.
        <boot_source> is either 'volume' or 'image'

    """
    table_ = table_parser.table(cli.nova('show', vm_id, ssh_client=con_ssh, auth_info=auth_info))
    image = table_parser.get_value_two_col_table(table_, 'image')
    if BOOT_FROM_VOLUME in image:
        volumes = _get_vm_volumes(table_)
        if len(volumes) == 0:
            raise exceptions.VMError("Booted from volume, but no volume id found.")
        elif len(volumes) == 1:
            LOG.info("VM booted from volume.")
            return {'type': 'volume', 'id': volumes[0]}
        else:
            LOG.info("VM booted from volume. Multiple volumes found, taking the first boot-able volume.")
            for volume in volumes:
                table_ = table_parser.table(cli.cinder('show', volume, auth_info=auth_info, ssh_client=con_ssh))
                bootable = table_parser.get_value_two_col_table(table_, 'bootable')
                if bootable.lower() == 'true':
                    return {'type': 'volume', 'id': volume}

            raise exceptions.VMError("Booted from volume, but no bootable volume attached.")

    else:
        match = re.search(UUID, image)
        return {'type': 'image', 'id': match.group(0)}


def get_vm_image_name(vm_id, auth_info=Tenant.ADMIN, con_ssh=None):
    """

    Args:
        vm_id (str):
        auth_info (dict):
        con_ssh (SSHClient):

    Returns (str): image name for the vm. If vm booted from volume, then image name in volume image metadata will be
        returned.

    """
    boot_info = get_vm_boot_info(vm_id, auth_info=auth_info, con_ssh=con_ssh)
    if boot_info['type'] == 'image':
        image_id = boot_info['id']
        image_show_table = table_parser.table(cli.glance('image-show', image_id))
        image_name = table_parser.get_value_two_col_table(image_show_table, 'name')
    else:      # booted from volume
        vol_show_table = table_parser.table(cli.cinder('show', boot_info['id'], auth_info=Tenant.ADMIN))
        image_meta_data = table_parser.get_value_two_col_table(vol_show_table, 'volume_image_metadata')
        image_meta_data = table_parser.convert_value_to_dict_cinder(image_meta_data)
        image_name = image_meta_data['image_name']

    return image_name


def _get_vm_volumes(novashow_table):
    """
    Args:
        novashow_table (dict):

    Returns (list: A list of volume ids from the novashow_table.

    """
    false = False
    true = True
    volumes = eval(table_parser.get_value_two_col_table(novashow_table, ':volumes_attached', strict=False))
    return [volume['id'] for volume in volumes]


def get_quotas(quotas=None, con_ssh=None, auth_info=None):
    """
    Get limit for given quota(s) via nova quota-show
    Args:
        quotas (list|str): name of the quota(s), e.g., 'instances', ['instances', 'cores']
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (list): list of limit(s) of given quota(s)

    """
    if not quotas:
        quotas = 'instances'
    if isinstance(quotas, str):
        quotas = [quotas]
    table_ = table_parser.table(cli.nova('quota-show', ssh_client=con_ssh, auth_info=auth_info))
    values = []
    for item in quotas:
        values.append(int(table_parser.get_value_two_col_table(table_, item)))

    return values


def update_quotas(tenant=None, force=False, con_ssh=None, auth_info=Tenant.ADMIN, **kwargs):
    """
    Update quota(s) with given key/value pair(s)
    Args:
        tenant (str): 'tenant1', 'tenant2'
        force (bool):
        con_ssh (SSHClient):
        auth_info (dict):
        **kwargs: quota/limit pair(s). Valid keys: user, instances, cores, ram, floating-ips, metadata-items, key-pairs

    Returns (None):

    """
    if tenant is None:
        tenant = Tenant.get_primary()['tenant']

    tenant_id = keystone_helper.get_tenant_ids(tenant_name=tenant, con_ssh=con_ssh)[0]
    if not kwargs:
        raise ValueError("Please specify at least one quota=value pair via kwargs.")

    args_ = ''
    for key, val in kwargs.items():
        if val is not None:
            key = key.strip().replace('_', '-')
            args_ += '--{} {} '.format(key, val)

    if force:
        args_ += '--force '
    args_ += tenant_id

    cli.nova('quota-update', args_, ssh_client=con_ssh, auth_info=auth_info)


# def set_image_metadata(image, fail_ok=False, auth_info=Tenant.ADMIN, con_ssh=None, **kwargs):
#     """
#     Set image metadata with given key/value pair(s)
#     Args:
#         image (str):
#         fail_ok (bool):
#         auth_info:
#         con_ssh:
#         **kwargs: metadata name/value pair(s) to set
#
#     Returns (tuple):
#         (0, "Image metadata is successfully set.")
#         (1, <stderr>)
#         (2, "Expected metadata <key> is not listed in nova image-show <image>")
#         (3, "Metadata <key> value is not set to <value> in nova image-show <image>")
#
#     """
#
#     LOG.info("Setting image {} metadata to: {}".format(image, kwargs))
#     if not kwargs:
#         raise ValueError("At least one key-value pair")
#
#     meta_args = ''
#     args_dict = {}
#     for key, value in kwargs.items():
#         key = key.lower().strip()
#         value = str(value).strip()
#         args_dict[key] = value
#         meta_data = "{}={}".format(key, value)
#         meta_args = ' '.join([meta_args, meta_data])
#
#     positional_args = ' '.join([image, 'set', meta_args])
#     code, output = cli.nova('image-meta', positional_args, ssh_client=con_ssh, auth_info=auth_info,
#                             fail_ok=fail_ok, rtn_list=True)
#
#     if code == 1:
#         return 1, output
#
#     LOG.info("Checking image {} metadata is set to {}".format(image, kwargs))
#     actual_metadata = get_image_metadata(image, list(args_dict.keys()), con_ssh=con_ssh)
#     for key, value in args_dict.items():
#         if key not in actual_metadata:
#             msg = "Expected metadata {} is not listed in nova image-show {}".format(key, image)
#             if fail_ok:
#                 LOG.warning(msg)
#                 return 2, msg
#             raise exceptions.ImageError(msg)
#
#         if actual_metadata[key] != value:
#             msg = "Metadata {} value is not set to {} in nova image-show {}".format(key, value, image)
#             if fail_ok:
#                 LOG.warning(msg)
#                 return 3, msg
#             raise exceptions.ImageError(msg)
#
#     msg = "Image metadata is successfully set."
#     LOG.info(msg)
#     return 0, msg


def get_image_metadata(image, meta_keys, auth_info=Tenant.ADMIN, con_ssh=None):
    """
    Get specified metadata as a dictionary for given image
    Args:
        image (str): id of image
        meta_keys (str|list): list of metadata key(s) to get value(s) for
        auth_info (dict): Admin by default
        con_ssh (SSHClient):

    Returns (dict): image metadata in a dictionary.
        Examples: {'hw_mem_page_size': any}
    """
    if isinstance(meta_keys, str):
        meta_keys = [meta_keys]

    for meta_key in meta_keys:
        str(meta_key).replace(':', '_')

    table_ = table_parser.table(cli.nova('image-show', image, ssh_client=con_ssh, auth_info=auth_info))
    results = {}
    for meta_key in meta_keys:
        meta_key = meta_key.strip()
        value = table_parser.get_value_two_col_table(table_, meta_key, strict=False)
        if value:
            results[meta_key] = value

    return results


# def delete_image_metadata(image, meta_keys, check_first=True, fail_ok=False, auth_info=Tenant.ADMIN, con_ssh=None):
#     """
#      Unset specific extra spec(s) from given flavor.
#
#      Args:
#          image (str): id of the flavor
#          con_ssh (SSHClient):
#          auth_info (dict):
#          fail_ok (bool):
#          meta_keys (str|list): metadata(s) to be removed. At least one should be provided.
#
#      Returns (tuple): (rtn_code (int), message (str))
#          (0, 'Image metadata unset successfully.'): required extra spec(s) removed successfully
#          (1, <stderr>): unset image metadata cli rejected
#          (2, '<metadata> is still in the extra specs list'): post action check failed
#
#      """
#
#     LOG.info("Deleting image metadata: {}".format(meta_keys))
#     if check_first:
#         if not get_image_metadata(image, meta_keys, auth_info=auth_info, con_ssh=con_ssh):
#             msg = "Metadata {} not exist in nova image-show. Do nothing.".format(meta_keys)
#             LOG.info(msg)
#             return -1, msg
#
#     if isinstance(meta_keys, str):
#         meta_keys = [meta_keys]
#
#     for meta_key in meta_keys:
#         str(meta_key).replace(':', '_')
#
#     meta_keys_args = ' '.join(meta_keys)
#     exit_code, output = cli.nova('image-meta', '{} delete {}'.format(image, meta_keys_args), fail_ok=fail_ok,
#                                  ssh_client=con_ssh, auth_info=auth_info, rtn_list=True)
#     if exit_code == 1:
#         return 1, output
#
#     post_meta_keys = get_image_metadata(image, meta_keys, con_ssh=con_ssh, auth_info=auth_info)
#     for key in meta_keys:
#         if key in post_meta_keys:
#             err_msg = "{} is still in the image metadata after deletion.".format(key)
#             if fail_ok:
#                 LOG.warning(err_msg)
#                 return 2, err_msg
#             raise exceptions.ImageError(err_msg)
#     else:
#         success_msg = "Image metadata unset successfully."
#         LOG.info(success_msg)
#         return 0, success_msg


def copy_flavor(from_flavor_id, new_name=None, con_ssh=None):
    """
    Extract the info from an existing flavor and create a new flavor that is has identical info

    Args:
        from_flavor_id (str): id of an existing flavor to extract the info from
        new_name:
        con_ssh:

    Returns (str): flavor_id

    """
    table_ = table_parser.table(cli.nova('flavor-show', from_flavor_id, ssh_client=con_ssh, auth_info=Tenant.ADMIN))

    extra_specs = eval(table_parser.get_value_two_col_table(table_, 'extra_specs'))
    ephemeral = table_parser.get_value_two_col_table(table_, 'ephemeral', strict=False)
    disk = table_parser.get_value_two_col_table(table_, 'disk')
    is_public = table_parser.get_value_two_col_table(table_, 'is_public', strict=False)
    ram = table_parser.get_value_two_col_table(table_, 'ram')
    rxtx_factor = table_parser.get_value_two_col_table(table_, 'rxtx_factor')
    swap = table_parser.get_value_two_col_table(table_, 'swap')
    vcpus = table_parser.get_value_two_col_table(table_, 'vcpus')
    old_name = table_parser.get_value_two_col_table(table_, 'name')

    if new_name is not None:
        new_name = "{}-{}".format(old_name, new_name)
    swap = swap if swap else 0
    new_flavor_id = create_flavor(name=new_name, vcpus=vcpus, ram=ram, swap=swap, root_disk=disk, ephemeral=ephemeral,
                                  is_public=is_public, rxtx_factor=rxtx_factor, con_ssh=con_ssh,
                                  check_storage_backing=False)[1]
    set_flavor_extra_specs(new_flavor_id, con_ssh=con_ssh, **extra_specs)

    return new_flavor_id


def get_provider_net_info(providernet_id, field='pci_pfs_configured', strict=True, auth_info=Tenant.ADMIN,
                          con_ssh=None, rtn_int=True):
    """
    Get provider net info from "nova providernet-show"

    Args:
        providernet_id (str): id of a providernet
        field (str): Field name such as pci_vfs_configured, pci_pfs_used, etc
        strict (bool): whether to perform a strict search on field name
        auth_info (dict):
        con_ssh (SSHClient):
        rtn_int (bool): whether to return integer or string

    Returns (int|str): value of specified field. Convert to integer by default unless rnt_int=False.

    """
    if not providernet_id:
        raise ValueError("Providernet id is not provided.")

    table_ = table_parser.table(cli.nova('providernet-show', providernet_id, ssh_client=con_ssh, auth_info=auth_info))
    info_str = table_parser.get_value_two_col_table(table_, field, strict=strict)
    return int(info_str) if rtn_int else info_str


def get_pci_interface_stats_for_providernet(providernet_id, fields=('pci_pfs_configured', 'pci_pfs_used',
                                                                    'pci_vfs_configured', 'pci_vfs_used'),
                                            auth_info=Tenant.ADMIN, con_ssh=None):
    """
    get pci interface usage
    Args:
        providernet_id (str): id of a providernet
        fields: fields such as ('pci_vfs_configured', 'pci_pfs_used')
        auth_info (dict):
        con_ssh (SSHClient):

    Returns (tuple): tuple of integers

    """
    if not providernet_id:
        raise ValueError("Providernet id is not provided.")

    table_ = table_parser.table(cli.nova('providernet-show', providernet_id, ssh_client=con_ssh, auth_info=auth_info))
    rtn_vals = []
    for field in fields:
        pci_stat = int(table_parser.get_value_two_col_table(table_, field, strict=True))
        rtn_vals.append(pci_stat)
    return tuple(rtn_vals)


def get_vm_interfaces_info(vm_id, nic_names=None, vif_model=None, mac_addr=None, pci_addr=None,
                           net_id=None, net_name=None, auth_info=Tenant.ADMIN, con_ssh=None):
    """
    Get vm interface info for given nic from nova show
    Args:
        vm_id (str): id of the vm to get interface info for
        nic_names (str|list): nic name such as nic1, nic2, etc
        vif_model (str): such as virtio, pci-sriov
        mac_addr (str):
        pci_addr (str):
        net_id (str): network id to filter out the vm nic
        net_name (str): network name. This is only used if net_id is None.
        auth_info (dict):
        con_ssh (SSHClient):

    Returns (list): such as [{"vif_model": "pci-passthrough", "network": "internal0-net1", "port_id":
        "33990477-dce6-4447-b153-4dee596fe3f4", "mtu": 9000, "mac_address": "90:e2:ba:60:c8:08", "vif_pci_address": ""}]

    """
    if not vm_id and vm_id not in ['0', 0]:
        raise ValueError("VM ID is not provided.")
    if nic_names is not None:
        if isinstance(nic_names, str):
            nic_names = [nic_names]
        for nic in nic_names:
            if "nic" not in nic:
                raise ValueError("Invalid nic(s) provided: {}. Should be in the form of: e.g., nic4".format(nic_names))

    if net_id:
        nets_tab = table_parser.table(cli.neutron('net-list', auth_info=auth_info, ssh_client=con_ssh))
        net_name = table_parser.get_values(nets_tab, 'name', id=net_id)[0]

    table_ = table_parser.table(cli.nova('show', vm_id, auth_info=auth_info, ssh_client=con_ssh))
    all_nics = table_parser.get_value_two_col_table(table_, field='wrs-if:nics', merge_lines=False)
    if isinstance(all_nics, str):
        all_nics = [all_nics]
    all_nics = [eval(nic_) for nic_ in all_nics]

    # Sort the nics from nic1, nic2 ... nicN
    all_nics = sorted(all_nics, key=lambda nic_: int((list(nic_.keys())[0]).split(sep='nic')[-1]))
    LOG.debug("All nics: {}".format(all_nics))

    nics_to_rtn = list(all_nics)
    if not nics_to_rtn:
        LOG.warning("No nics attached to vm {}".format(vm_id))
        return []
    elif vif_model or nic_names or mac_addr or pci_addr or net_name:
        for item in all_nics:
            nic_info = list(item.values())[0]
            if (vif_model and vif_model != nic_info['vif_model']) or \
                    (mac_addr and mac_addr != nic_info['mac_address']) or \
                    (pci_addr and pci_addr != nic_info['vif_pci_address']) or \
                    (net_name and net_name != nic_info['network']):
                nics_to_rtn.remove(item)

            if nic_names:
                for nic_name in nic_names:
                    if nic_name not in item:
                        nics_to_rtn.remove(item)
            LOG.debug("nics_to_rtn: {}".format(nics_to_rtn))

        if not nics_to_rtn:
            LOG.warning("Cannot find nic info with given criteria")
            return []

    nics_to_rtn = [list(nic_.values())[0] for nic_ in nics_to_rtn]
    LOG.info("nics with nic_names {} and vif_model {}: {}".format(nic_names, vif_model, nics_to_rtn))
    return nics_to_rtn


def get_vm_instance_name(vm_id, con_ssh=None):
    return get_vm_nova_show_value(vm_id, ":instance_name", strict=False, con_ssh=con_ssh)


def get_nova_services_table(auth_info=Tenant.ADMIN, con_ssh=None):
    return table_parser.table(cli.nova('service-list', ssh_client=con_ssh, auth_info=auth_info))


def create_aggregate(rtn_val='name', name=None, avail_zone=None, check_first=True, fail_ok=False, con_ssh=None,
                     auth_info=Tenant.ADMIN):
    """
    Add a aggregate with given name and availability zone.

    Args:
        rtn_val (str): name or id
        name (str): name for aggregate to create
        avail_zone (str):
        check_first (bool)
        fail_ok (bool):
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (tuple):
        (0, <rtn_val>)          -- aggregate successfully created
        (1, <stderr>)           -- cli rejected
        (2, "Created aggregate is not as specified")    -- name and/or availability zone mismatch

    """
    if not name:
        existing_names = get_aggregates(rtn_val='name')
        name = common.get_unique_name(name_str='cgcsauto', existing_names=existing_names)

    subcmd = name
    if avail_zone:
        subcmd += ' {}'.format(avail_zone)

    if check_first:
        aggregates_ = get_aggregates(rtn_val=rtn_val, name=name, avail_zone=avail_zone)
        if aggregates_:
            LOG.warning("Aggregate {} already exists. Do nothing.".format(name))
            return -1, aggregates_[0]

    LOG.info("Adding aggregate {}".format(name))

    res, out = cli.nova('aggregate-create', subcmd, ssh_client=con_ssh, auth_info=auth_info, rtn_list=True,
                        fail_ok=fail_ok)
    if res == 1:
        return res, out

    out_tab = table_parser.table(out)
    expt_avail = avail_zone if avail_zone else ''
    actual_values = table_parser.get_values(out_tab, rtn_val, **{'Name': name, 'Availability Zone': expt_avail})

    if not actual_values:
        err_msg = "Created aggregate is not as specified"
        if fail_ok:
            return 2, err_msg
        else:
            raise exceptions.NovaError(err_msg)

    succ_msg = "Aggregate {} is successfully created".format(name)
    LOG.info(succ_msg)
    return 0, actual_values[0]


def get_aggregates(rtn_val='name', name=None, avail_zone=None, con_ssh=None, auth_info=Tenant.ADMIN):
    """
    Get a list of aggregates

    Args:
        rtn_val (str): id or name
        name (str): filter out the aggregates with given name if specified
        avail_zone (str): filter out the aggregates with given availability zone if specified
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (list):

    """
    kwargs = {}
    if avail_zone:
        kwargs['Availability Zone'] = avail_zone

    if name:
        kwargs['Name'] = name

    aggregates_tab = table_parser.table(cli.nova('aggregate-list', ssh_client=con_ssh, auth_info=auth_info))
    return table_parser.get_values(aggregates_tab, rtn_val, **kwargs)


def delete_aggregate(name, check_first=True, remove_hosts=True, fail_ok=False, con_ssh=None, auth_info=Tenant.ADMIN):
    """
    Add a aggregate with given name and availability zone.

    Args:
        name (str): name for aggregate to delete
        check_first (bool)
        remove_hosts (bool)
        fail_ok (bool):
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (tuple):
        (0, "Aggregate <name> is successfully deleted")          -- aggregate successfully deletec
        (1, <stderr>)           -- cli rejected
        (2, "Aggregate <name> still exists in aggregate-list after deletion")    -- failed although cli accepted

    """
    if check_first:
        if not get_aggregates(name=name):
            msg = 'Aggregate {} does not exists. Do nothing.'.format(name)
            LOG.warning(msg)
            return -1, msg

    if remove_hosts:
        remove_hosts_from_aggregate(aggregate=name, check_first=True)

    LOG.info("Deleting aggregate {}".format(name))

    res, out = cli.nova('aggregate-delete', name, ssh_client=con_ssh, auth_info=auth_info, rtn_list=True,
                        fail_ok=fail_ok)
    if res == 1:
        return res, out

    post_aggregates = get_aggregates(rtn_val='name', con_ssh=con_ssh, auth_info=auth_info)
    if name in post_aggregates:
        err_msg = "Aggregate {} still exists in aggregate-list after deletion."
        if fail_ok:
            LOG.warning(err_msg)
            return 2, err_msg
        else:
            raise exceptions.NovaError(err_msg)

    succ_msg = "Aggregate {} is successfully deleted".format(name)
    LOG.info(succ_msg)
    return 0, succ_msg


def remove_hosts_from_aggregate(aggregate, hosts=None, check_first=True, fail_ok=False, con_ssh=None,
                                auth_info=Tenant.ADMIN):
    """
    Remove hosts from specified aggregate

    Args:
        aggregate (str): name of the aggregate to remove hosts. cgcsauto aggregate can be added via add_cgcsauto_zone
            session fixture
        hosts (list|str): host(s) to remove from aggregate
        check_first (bool):
        fail_ok (bool):
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (tuple):
        (0, "Hosts successfully removed from aggregate")
        (1, <stderr>)       cli rejected on at least one host
        (2, "Host(s) still exist in aggregate <aggr> after aggregate-remove-host: <unremoved_hosts>)

    """
    __remove_or_add_hosts_in_aggregate(remove=True, aggregate=aggregate, hosts=hosts, check_first=check_first,
                                       fail_ok=fail_ok, con_ssh=con_ssh, auth_info=auth_info)


def add_hosts_to_aggregate(aggregate, hosts, check_first=True, fail_ok=False, con_ssh=None, auth_info=Tenant.ADMIN):
    """
    Add host(s) to specified aggregate

    Args:
        aggregate (str): name of the aggregate to add hosts. cgcsauto aggregate can be added via add_cgcsauto_zone
            session fixture
        hosts (list|str): host(s) to add to aggregate
        check_first (bool):
        fail_ok (bool):
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (tuple):
        (0, "Hosts successfully added from aggregate")
        (1, <stderr>)       cli rejected on at least one host
        (2, "aggregate-add-host accepted, but some host(s) are not added in aggregate")

    """
    __remove_or_add_hosts_in_aggregate(remove=False, aggregate=aggregate, hosts=hosts, check_first=check_first,
                                       fail_ok=fail_ok, con_ssh=con_ssh, auth_info=auth_info)


def __remove_or_add_hosts_in_aggregate(aggregate, hosts=None, remove=False, check_first=True, fail_ok=False,
                                       con_ssh=None, auth_info=Tenant.ADMIN):
    """
    Remove/Add hosts from/to given aggregate

    Args:
        aggregate (str): name of the aggregate to add/remove hosts. cgcsauto aggregate can be added via
            add_cgcsauto_zone session fixture
        hosts (list|str):
        remove (bool): True if remove hosts from given aggregate, otherwise add hosts to aggregate
        check_first (bool):
        fail_ok (bool):
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (tuple):
        (0, "Hosts successfully removed from aggregate")
        (1, <stderr>)       cli rejected on at least one host
        (2, "Host(s) still exist in aggregate <aggr> after aggregate-remove-host: <unremoved_hosts>)

    """
    hosts_in_aggregate = host_helper.get_hosts_in_aggregate(aggregate, con_ssh=con_ssh)

    if hosts is None:
        if remove:
            hosts = hosts_in_aggregate
        else:
            hosts = host_helper.get_hosts()

    if isinstance(hosts, str):
        hosts = [hosts]

    msg_str = 'Remov' if remove else 'Add'
    LOG.info("{}ing hosts {} in aggregate {}".format(msg_str, hosts, aggregate))
    if check_first:
        if remove:
            hosts_to_rm_or_add = list(set(hosts) & set(hosts_in_aggregate))
        else:
            hosts_to_rm_or_add = list(set(hosts) - set(hosts_in_aggregate))
    else:
        hosts_to_rm_or_add = list(hosts)

    if not hosts_to_rm_or_add:
        warn_str = 'No' if remove else 'All'
        msg = "{} given host(s) in aggregate {}. Do nothing. Given hosts: {}; hosts in aggregate: {}".\
            format(warn_str, aggregate, hosts, hosts_in_aggregate)
        LOG.warning(msg)
        return -1, msg

    failed_res = {}
    cmd = 'aggregate-remove-host' if remove else 'aggregate-add-host'
    for host in hosts_to_rm_or_add:
        args = '{} {}'.format(aggregate, host)
        code, output = cli.nova(cmd, args, ssh_client=con_ssh, auth_info=auth_info, fail_ok=True, rtn_list=True)
        if code == 1:
            failed_res[host] = output

    if failed_res:
        err_msg = "'{}' is rejected for following host(s) in aggregate {}: {}".format(cmd, aggregate, failed_res)
        if fail_ok:
            LOG.warning(err_msg)
            return 1, err_msg
        else:
            raise exceptions.NovaError(err_msg)

    post_hosts_in_aggregate = host_helper.get_hosts_in_aggregate(aggregate, con_ssh=con_ssh)
    if remove:
        failed_hosts = list(set(hosts) & set(post_hosts_in_aggregate))
    else:
        failed_hosts = list(set(hosts) - set(post_hosts_in_aggregate))

    if failed_hosts:
        err_msg = "{} accepted, but some host(s) are not {}ed in aggregate {}: {}".format(cmd, msg_str, aggregate,
                                                                                          failed_hosts)
        if fail_ok:
            LOG.warning(err_msg)
            return 2, err_msg
        else:
            raise exceptions.NovaError(err_msg)

    succ_msg = "Hosts successfully {}ed in aggregate {}: {}".format(msg_str.lower(), aggregate, hosts)
    LOG.info(succ_msg)
    return 0, succ_msg


def run_migration_list(con_ssh=None, auth_info=Tenant.ADMIN):
    """
    nova migration-list to collect migration history of each vm
    Args:
        con_ssh (SSHClient):
        auth_info (dict):

    """
    LOG.info("Listing migration history...")
    cli.nova('migration-list', ssh_client=con_ssh, auth_info=auth_info)


def get_compute_with_cpu_model(hosts, cpu_models, con_ssh=None, auth_info=Tenant.ADMIN):
    """
    nova migration-list to collect migration history of each vm
    Args:
        hosts: one or more compute nodes
        cpu_models: cpu models to match
        con_ssh (SSHClient):
        auth_info (dict):

    Returns (list): List of matching hosts

    """
    field = 'cpu_info_model'
    return_hosts = []
    for host in hosts:
        LOG.info("Getting cpu model info...")
        table_ = table_parser.table(cli.nova('hypervisor-show', host, ssh_client=con_ssh,
                                             auth_info=auth_info))
        host_cpu_model = table_parser.get_value_two_col_table(table_, field, strict=True, merge_lines=True)
        if host_cpu_model in cpu_models:
            return_hosts.append(host)

    return return_hosts
